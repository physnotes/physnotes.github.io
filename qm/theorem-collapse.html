<script>
(() => {
  const KINDS = ["example","remark"];   // only these are collapsible
  const DURATION = 150;                  // ms
  const EASING = "ease";                 // timing
  const REDUCE_MOTION = window.matchMedia &&
    window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  function findTitleNode(box, kind) {
    let t = box.querySelector(`.${kind}-title`);
    if (t) return t;
    t = box.querySelector('[class$="-title"]');
    if (t) return t;
    const first = box.firstElementChild;
    if (first && /^H[1-6]$/i.test(first.tagName)) return first;
    return box.querySelector("strong, h1, h2, h3, h4, h5, h6, span");
  }

  function clearBodyStyles(body) {
    body.style.transition = "";
    body.style.height = "";
    body.style.overflow = "";
  }

  function animateOpen(det, body) {
    if (REDUCE_MOTION) { det.open = true; clearBodyStyles(body); return; }

    // Open first so Firefox can compute a real scrollHeight
    det.open = true;

    // Prep for animation
    body.style.overflow = "hidden";
    body.style.height = "0px";
    body.style.transition = `height ${DURATION}ms ${EASING}`;

    // Reflow so the browser registers height:0
    void body.offsetHeight;

    // Firefox sometimes needs one more frame before scrollHeight is valid
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        const target = body.scrollHeight + "px";
        body.style.height = target;

        const done = () => { clearBodyStyles(body); body.removeEventListener("transitionend", done); };
        body.addEventListener("transitionend", done);
        // Fallback in case transitionend is missed
        setTimeout(done, DURATION + 60);
      });
    });
  }

  function animateClose(det, body) {
    if (REDUCE_MOTION) { det.open = false; clearBodyStyles(body); return; }

    // Fix current height as start value
    const start = body.scrollHeight + "px";
    body.style.overflow = "hidden";
    body.style.height = start;
    body.style.transition = `height ${DURATION}ms ${EASING}`;

    // Reflow so the start height is committed
    void body.offsetHeight;

    // Then collapse to 0
    body.style.height = "0px";

    const done = () => {
      det.open = false; // actually close after animation finishes
      clearBodyStyles(body);
      body.removeEventListener("transitionend", done);
    };
    body.addEventListener("transitionend", done);
    setTimeout(done, DURATION + 60);
  }

  function convertBox(box, kind) {
    if (box.dataset.detailsConverted) return;

    const title = findTitleNode(box, kind);
    if (!title) return;

    // Build <details>/<summary>
    const det = document.createElement("details");
    det.open = true;                 // set false if you prefer default-collapsed
    det.className = box.className;   // keep .example/.remark etc.
    if (box.id) det.id = box.id;

    const sum = document.createElement("summary");
    sum.classList.add(`${kind}-title`);
    sum.innerHTML = title.innerHTML;
    title.remove();

    const body = document.createElement("div");
    body.className = "details-body";
    while (box.firstChild) body.appendChild(box.firstChild);

    // Prevent flash of content if starting collapsed
    if (!det.open) { body.style.height = "0px"; body.style.overflow = "hidden"; }

    det.appendChild(sum);
    det.appendChild(body);
    box.replaceWith(det);

    // Override native toggle so we can animate
    const toggle = (e) => {
      e.preventDefault();               // stop instant UA toggle
      if (det.open) animateClose(det, body);
      else          animateOpen(det, body);
    };

    sum.addEventListener("click", toggle);
    sum.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); toggle(e); }
    });

    // a11y
    sum.setAttribute("role", "button");
    sum.setAttribute("tabindex", "0");

    det.dataset.detailsConverted = "1";
  }

  function processAll(root = document) {
    KINDS.forEach(kind => {
      root.querySelectorAll(`.${kind}`).forEach(box => convertBox(box, kind));
    });
  }

  document.addEventListener("DOMContentLoaded", () => processAll());
  window.addEventListener("load", () => processAll());
})();
</script>
